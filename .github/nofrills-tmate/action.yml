name: 'No-Frills Tmate Session'
description: 'Starts a minimal tmate debug session using Node.js to spawn the daemon.'

inputs:
  limit-access-to-actor:
    description: 'Ignored. Access is always limited to the actor.'
    required: false
    default: 'true'

runs:
  using: "composite"
  steps:
    - name: Run Tmate Debug Session
      shell: bash
      run: |
        # DO NOT use 'set -e'. We need to manually control error checking.

        export PATH=$PATH:/c/msys64/usr/bin
        export HOME=${GITHUB_WORKSPACE}
        SOCKET_FILE=${GITHUB_WORKSPACE}/tmate.sock
        
        echo "--- 1. Installing dependencies (tmate, curl, jq) ---"
        pacman -Sy --noconfirm --needed tmate curl jq || exit 1
        
        which tmate || exit 2
        tmate -V || exit 3

        echo "--- 2. Fetching SSH keys for ${{ github.actor }} ---"
        mkdir -p ${HOME}/.ssh || exit 11
        curl -s -H "Authorization: token $GH_TOKEN" \
             "https://api.github.com/users/${{ github.actor }}/keys" | \
             jq -r '.[].key' > ${HOME}/.ssh/authorized_keys || exit 12
        chmod 600 ${HOME}/.ssh/authorized_keys || exit 13

        echo "--- 3. Launching tmate daemon via Node.js (THE FIX) ---"
        # This is the new, non-blocking approach.
        # We use Node.js 'spawn' with 'detached' and 'ignore'
        # to perfectly replicate the original action's logic
        # and prevent all stdio deadlocks.
        node -e "
          const { spawn } = require('child_process');
          const socket = '${SOCKET_FILE}';
          const keys = '${HOME}/.ssh/authorized_keys';
          
          const args = [
            '-S', socket,
            '-a', keys,
            'set-option', '-g', 'status', 'off', ';',
            'set-option', '-g', 'default-command', 'bash', ';',
            'new-session', '-d'
          ];

          const child = spawn('tmate', args, {
            detached: true,
            stdio: 'ignore',
            env: { ...process.env, 'CHERE_INVOKING': '1' } // Add the env var just in case
          });

          child.unref();
          console.log('Node.js has successfully spawned the tmate daemon.');
        "
        
        if [[ $? -ne 0 ]]; then
            echo "!!!!!!!!!!!!!!!!! ERROR !!!!!!!!!!!!!!!!!"
            echo "Node.js spawn command FAILED."
            echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
            exit 41
        fi

        echo "--- 3.5. WAITING FOR SOCKET FILE ${SOCKET_FILE} ---"
        # Now we poll for the socket file, which is reliable.
        SOCKET_EXISTS=0
        for i in $(seq 1 15); do
          if [[ -e "${SOCKET_FILE}" ]]; then
            echo "SUCCESS: Socket file found after $i seconds."
            SOCKET_EXISTS=1
            break
          fi
          echo "Waiting for socket... ($i/15s)"
          sleep 1
        done

        if [[ $SOCKET_EXISTS -eq 0 ]]; then
            echo "!!!!!!!!!!!!!!!!! ERROR !!!!!!!!!!!!!!!!!"
            echo "Tmate process TIMED OUT. Socket file was never created."
            echo "The daemon likely crashed. Check the log (if any) or setup."
            echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
            exit 42
        fi

        echo "--- 4. Polling for valid SSH string (max 15s) ---"
        TMATE_SSH=""
        START_POLL=$(date +%s)

        while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_POLL))

            if [[ $ELAPSED -gt 15 ]]; then
                echo "!!!!!!!!!!!!!!!!! ERROR !!!!!!!!!!!!!!!!!"
                echo "TIMED OUT waiting for valid connection string."
                echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                exit 45
            fi

            TMATE_SSH=$(tmate -S ${SOCKET_FILE} display -p '#{tmate_ssh}' 2>/dev/null)
            DISPLAY_EXIT_CODE=$?

            if [[ $DISPLAY_EXIT_CODE -ne 0 ]]; then
                echo "!!!!!!!!!!!!!!!!! ERROR !!!!!!!!!!!!!!!!!"
                echo "Tmate 'display' command FAILED (Code: $DISPLAY_EXIT_CODE)."
                echo "This means the daemon has CRASHED."
                echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
                exit 46
            fi

            # Check for the literal string. Your log showed '#tmate_ssh'
            if [[ -n "${TMATE_SSH}" && "${TMATE_SSH}" != "#tmate_ssh" ]]; then
                echo "SUCCESS: Got connection string after $ELAPSED seconds."
                break
            fi
            
            sleep 1
        done

        echo "SSH: $TMATE_SSH"
        echo "Create a file named 'continue' in the repo root to proceed."

        echo "--- 5. Waiting for connection or exit signal ---"
        TIMEOUT=300 # 5 minutes
        START_TIME=$(date +%s)
        CLIENT_CONNECTED=0

        while true; do
          if [[ -f "${GITHUB_WORKSPACE}/continue" ]]; then
            echo "Found 'continue' file. Ending tmate session."
            break
          fi
          if [[ ! -e ${SOCKET_FILE} ]]; then
            echo "Tmate session ended (socket file gone)."
            break
          fi

          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))

          if [[ $CLIENT_CONNECTED -eq 0 ]]; then
            CLIENT_COUNT=$(tmate -S ${SOCKET_FILE} display -p '#{tmate_num_clients}' 2>/dev/null || echo "")
            
            if ! [[ "${CLIENT_COUNT}" =~ ^[0-9]+$ ]]; then
                echo "Client count read error, got: '${CLIENT_COUNT}'. Assuming 0."
                CLIENT_COUNT=0
            fi

            if [[ $CLIENT_COUNT -ne 0 ]]; then
              echo "Client connected! (Count: $CLIENT_COUNT). Disarming 5-minute idle timeout."
              CLIENT_CONNECTED=1
            else
              if [[ $ELAPSED -gt $TIMEOUT ]]; then
                echo "Tmate session timed out after 5 minutes (no connection)."
                break
              else
                REMAINING=$((TIMEOUT - ELAPSED))
                echo "Waiting for client connection ($REMAINING seconds remaining)..."
              fi
            fi
          else
            echo "Client connected. Waiting for session to end..."
          fi
          sleep 5
        done

        echo "--- 6. Cleanup ---"
        tmate -S ${SOCKET_FILE} kill-session || echo "Tmate session already closed."